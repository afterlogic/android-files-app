import groovy.swing.SwingBuilder

ext{
    getIncrementalVersionCode = this.&getIncrementalVersionCode
    getIncrementalVersionName = this.&getIncrementalVersionName
    getLastBuildReleaseNoteFile = this.&getLastBuildReleaseNoteFile
    prepareVersions = this.&prepareVersions
}

/**
 * Result apk naming.
 */
android.applicationVariants.all { variant ->

    def appName
    //Check if an applicationName property is supplied; if not use the name of the parent project.
    if (project.hasProperty("applicationName")) {
        appName = applicationName
    } else {
        appName = parent.name
    }

    variant.outputs.all { output ->
        def newApkName
        //If there's no ZipAlign task it means that our artifact will be unaligned and we need to mark it as such.
        if (output.zipAlign) {
            newApkName = "${appName}-${project.name}-${output.baseName}-${variant.versionName}-b${variant.versionCode}.apk"
        } else {
            newApkName = "${appName}-${project.name}-${output.baseName}-${variant.versionName}-b${variant.versionCode}-unaligned.apk"
        }
        outputFileName = newApkName
    }
}

void prepareVersions() {

    Properties versionProperties = new Properties()
    File propsFile = getVersionFile()

    if(propsFile.exists()) {
        versionProperties.load(new FileInputStream(propsFile))
    } else {
        throw new IllegalStateException("Signing properties file not exist! File: " + propsFile.absolutePath)
    }

    if(checkAndInit(versionProperties)
            || isNeedIncrement() && checkVersionChanges(versionProperties)) {

        versionProperties.store(propsFile.newWriter(), null)

    }
}

/**
 * Get version code from version.properties file and increment it if increment flag setted.
 */
int getIncrementalVersionCode() {

    Properties versionProperties = new Properties()
    File propsFile = getVersionFile()

    if(propsFile.exists()) {
        versionProperties.load(new FileInputStream(propsFile))
    } else {
        throw new IllegalStateException("Signing properties file not exist! File: " + propsFile.absolutePath)
    }

    return versionProperties["VERSION_CODE"].toString().toInteger()
}

String getIncrementalVersionName() {

    Properties versionProperties = new Properties()
    File propsFile = getVersionFile()

    if(propsFile.exists()) {
        versionProperties.load(new FileInputStream(propsFile))
    } else {
        throw new IllegalStateException("Signing properties file not exist! File: " + propsFile.absolutePath)
    }

    return versionProperties["VERSION_NAME"]
}



def getLastBuildReleaseNoteFile() {

    def lastbuildNote = file(projectDir.absolutePath + "/lastBetaBuildNotes.txt")

    if (!lastbuildNote.exists()){
        new File(projectDir.absolutePath + "/lastBetaBuildNotes.txt").withWriterAppend { w ->
            w << "Initial release note."
        }
    }

    return projectDir.absolutePath + "/lastBetaBuildNotes.txt"
}

private static boolean checkAndInit(Properties properties) {

    def changed = false

    if (properties["VERSION_NAME"] == null){
        properties["VERSION_NAME"] = "0.0.0"
        changed = true
    }

    if (properties["VERSION_CODE"] == null){
        properties["VERSION_CODE"] = "1"
        changed = true
    }

    return changed
}

private static boolean checkVersionChanges(Properties properties) {

    String[] versions = properties["VERSION_NAME"].toString().split("\\.")

    boolean cancelled = false
    boolean changed = true

    new SwingBuilder().edt {

        dialog(modal: true, // Otherwise the build will continue running before you closed the dialog
                title: 'Build version.', // Dialog title
                alwaysOnTop: true, // pretty much what the name says
                resizable: false, // Don't allow the user to resize the dialog
                locationRelativeTo: null, // Place dialog in center of the screen
                pack: true, // We need to pack the dialog (so it will take the size of it's children)
                show: true // Let's show it
        ) {

            vbox { // Put everything below each other
                label(text: "What version changes?")
                button(text: 'Global (1.x.x)', actionPerformed: {
                    versions[0] = String.valueOf(versions[0].toInteger() + 1)
                    versions[1] = "0"
                    versions[2] = "0"
                    dispose() // Close dialog
                })
                button(text: 'Major (x.1.x)', actionPerformed: {
                    versions[1] = String.valueOf(versions[1].toInteger() + 1)
                    versions[2] = "0"
                    dispose() // Close dialog
                })
                button(text: 'Minor (x.x.1)', actionPerformed: {
                    versions[2] = String.valueOf(versions[2].toInteger() + 1)
                    dispose() // Close dialog
                })
                button(defaultButton: true, text: 'Internal (only buildNumber)', actionPerformed: {
                    dispose() // Close dialog
                })
                button(text: 'Same (nothing)', actionPerformed: {
                    changed = false
                    dispose() // Close dialog
                })
                button(text: 'Cancel', actionPerformed: {
                    cancelled = true
                    dispose() // Close dialog
                })
            } // vbox end

        } // dialog end

    } // edt end

    if (cancelled){
        throw new Exception("Cancelled.")
    }

    if (changed) {
        properties["VERSION_NAME"] = versions.join(".")
        properties["VERSION_CODE"] = String.valueOf(properties["VERSION_CODE"].toString().toInteger() + 1)
    }

    return changed
}

private boolean isNeedIncrement() {

    def autoIncrementTasks = project.ext.get("autoIncrementTasks")

    if (autoIncrementTasks != null) {

        List<String> incrementTasks = ((String)autoIncrementTasks).split(",")
                .collect { it.trim() }

        return gradle.startParameter.getTaskNames()
                .any { task ->
                    incrementTasks.any { it == task }
                }
    }

    return false
}

private def getVersionFile() {

    def versionPropsFile = file(projectDir.absolutePath + '/version.properties')

    if (!versionPropsFile.exists()){
        versionPropsFile = new File(projectDir.absolutePath + '/version.properties').withWriterAppend { w ->
            w << ""
        }
    }

    return versionPropsFile
}